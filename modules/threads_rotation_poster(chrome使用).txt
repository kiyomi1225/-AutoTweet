# modules/threads_rotation_poster.py - Threadså¾ªç’°æŠ•ç¨¿
import time
import random
import pyautogui
import csv  
from pathlib import Path
from typing import List, Dict, Optional

try:
    from .logger_setup import setup_module_logger
except ImportError:
    import sys
    sys.path.append('.')
    from modules.logger_setup import setup_module_logger

class ThreadsRotationPoster:
    def __init__(self, config_manager, vpn_manager, chrome_manager):
        """Threadså¾ªç’°æŠ•ç¨¿ã‚¯ãƒ©ã‚¹"""
        self.config_manager = config_manager
        self.vpn_manager = vpn_manager
        self.chrome_manager = chrome_manager
        self.logger = setup_module_logger("ThreadsRotationPoster")
        # åŸºæœ¬ãƒ‡ãƒ¼ã‚¿ãƒ‘ã‚¹è¿½åŠ 
        self.base_data_path = Path("C:/Users/shiki/AutoTweet/data")
        
        # ç”»åƒèªè­˜è¨­å®š
        self.images_config = config_manager.get_images_config()
        self.image_dir = Path(self.images_config.get("image_dir", "images"))
        self.confidence = self.images_config.get("confidence", 0.8)
        
        # PyAutoGUIè¨­å®š
        pyautogui.FAILSAFE = True
        pyautogui.PAUSE = 1
        
        self.logger.info("Threadså¾ªç’°æŠ•ç¨¿ã‚’åˆæœŸåŒ–ã—ã¾ã—ãŸ")

    def _get_csv_path(self, account_id: str) -> Path:
        """ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã®CSVãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’å–å¾—"""
        return self.base_data_path / account_id / "tweets.csv"
    
    def count_unused_tweets(self, account_id: str) -> int:
        """æœªä½¿ç”¨ãƒ„ã‚¤ãƒ¼ãƒˆæ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ"""
        csv_path = self._get_csv_path(account_id)
        if not csv_path.exists():
            return 0
        
        count = 0
        with open(csv_path, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            for row in reader:
                if row.get('used', '').lower() in ['false', '0', '']:
                    count += 1
        return count
    
    def get_random_unused_tweet(self, account_id: str) -> Optional[Dict[str, str]]:
        """ãƒ©ãƒ³ãƒ€ãƒ ã«æœªä½¿ç”¨ãƒ„ã‚¤ãƒ¼ãƒˆã‚’å–å¾—"""
        csv_path = self._get_csv_path(account_id)
        if not csv_path.exists():
            return None
        
        unused_tweets = []
        with open(csv_path, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            for row in reader:
                if row.get('used', '').lower() in ['false', '0', '']:
                    unused_tweets.append(row)
        
        if unused_tweets:
            return random.choice(unused_tweets)
        return None
    
    def mark_tweet_as_used(self, account_id: str, tweet_id: str) -> bool:
        """ãƒ„ã‚¤ãƒ¼ãƒˆã‚’ä½¿ç”¨æ¸ˆã¿ã«ãƒãƒ¼ã‚¯"""
        csv_path = self._get_csv_path(account_id)
        if not csv_path.exists():
            return False
        
        rows = []
        with open(csv_path, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            fieldnames = reader.fieldnames
            for row in reader:
                if row['id'] == tweet_id:
                    row['used'] = 'True'
                rows.append(row)
        
        with open(csv_path, 'w', newline='', encoding='utf-8') as f:
            writer = csv.DictWriter(f, fieldnames=fieldnames)
            writer.writeheader()
            writer.writerows(rows)
        return True
    
    def run_rotation_posting(self, account_ids: List[str], min_wait: int = 30, max_wait: int = 60) -> bool:
            """å¾ªç’°æŠ•ç¨¿å®Ÿè¡Œï¼ˆVPNåˆ‡ã‚Šæ›¿ãˆå¯¾å¿œç‰ˆï¼‰"""
            try:
                self.logger.info(f"Threadså¾ªç’°æŠ•ç¨¿é–‹å§‹: {account_ids}")
                
                # æ¯æ¸‡ã‚¹ã‚­ãƒƒãƒ—ç”¨ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãƒªã‚¹ãƒˆ
                active_accounts = account_ids.copy()
                
                while len(active_accounts) > 0:
                    for account_id in active_accounts.copy():
                        # æœªä½¿ç”¨ãƒ„ã‚¤ãƒ¼ãƒˆæ•°ãƒã‚§ãƒƒã‚¯
                        unused_count = self.count_unused_tweets(account_id)
                        if unused_count == 0:
                            self.logger.info(f"âŒ {account_id} æ¯æ¸‡ã«ã‚ˆã‚Šé™¤å¤–")
                            active_accounts.remove(account_id)
                            continue
                        
                        self.logger.info(f"ğŸ”„ {account_id} æŠ•ç¨¿é–‹å§‹ (æ®‹ã‚Š{unused_count}ä»¶)")
                        
                        # ã‚¢ã‚«ã‚¦ãƒ³ãƒˆæŠ•ç¨¿å®Ÿè¡Œï¼ˆVPNåˆ‡ã‚Šæ›¿ãˆå«ã‚€ï¼‰
                        success = self._post_for_account_with_vpn_switch(account_id)
                        
                        if success:
                            self.logger.info(f"âœ… {account_id} æŠ•ç¨¿æˆåŠŸ")
                        else:
                            self.logger.warning(f"âŒ {account_id} æŠ•ç¨¿å¤±æ•—")
                        
                        # æ¬¡ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¾ã§å¾…æ©Ÿï¼ˆâ—‹â—‹åˆ†ï¼‰
                        if len(active_accounts) > 1:  # æœ€å¾Œã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆä»¥å¤–
                            wait_minutes = random.randint(min_wait, max_wait)
                            self.logger.info(f"â³ æ¬¡ã®ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã¾ã§{wait_minutes}åˆ†å¾…æ©Ÿ...")
                            time.sleep(wait_minutes * 60)
                
                self.logger.info("ğŸ‰ å…¨ã‚¢ã‚«ã‚¦ãƒ³ãƒˆæ¯æ¸‡ã«ã‚ˆã‚Šå¾ªç’°æŠ•ç¨¿çµ‚äº†")
                return True
                
            except KeyboardInterrupt:
                self.logger.info("âš ï¸ ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã‚ˆã‚‹ä¸­æ–­")
                return False
            except Exception as e:
                self.logger.error(f"å¾ªç’°æŠ•ç¨¿ã‚¨ãƒ©ãƒ¼: {str(e)}")
                return False
            finally:
                # æœ€çµ‚VPNåˆ‡æ–­
                try:
                    self.vpn_manager.disconnect()
                    self.logger.info("æœ€çµ‚VPNåˆ‡æ–­å®Œäº†")
                except:
                    pass

    def _post_for_account_with_vpn_switch(self, account_id: str) -> bool:
        """VPNåˆ‡ã‚Šæ›¿ãˆä»˜ãã‚¢ã‚«ã‚¦ãƒ³ãƒˆæŠ•ç¨¿å‡¦ç†ï¼ˆã‚¹ãƒãƒ¼ãƒˆåˆ‡ã‚Šæ›¿ãˆç‰ˆï¼‰"""
        tweet_data = None
        
        try:
            # 1. ç¾åœ¨ã®IPã‚’è¨˜éŒ²
            current_ip_before = self.vpn_manager._get_current_ip()
            self.logger.info(f"ğŸ”„ VPNåˆ‡ã‚Šæ›¿ãˆé–‹å§‹: {account_id} (ç¾åœ¨IP: {current_ip_before})")
            
            # 2. æ—¢å­˜VPNæ¥ç¶šã‚’ç¢ºå®Ÿã«åˆ‡æ–­
            self.vpn_manager.disconnect()
            time.sleep(10)  # åˆ‡æ–­å®Œäº†å¾…æ©Ÿï¼ˆVPNãƒ—ãƒ­ã‚»ã‚¹çµ‚äº†ç¢ºä¿ï¼‰
            
            # 3. æŒ‡å®šã‚¢ã‚«ã‚¦ãƒ³ãƒˆå°‚ç”¨VPNã«æ¥ç¶š
            max_attempts = 3
            for attempt in range(max_attempts):
                vpn_success = self.vpn_manager.connect_account_vpn(account_id)
                if not vpn_success:
                    if attempt < max_attempts - 1:
                        self.logger.warning(f"VPNæ¥ç¶šå¤±æ•—ã€ãƒªãƒˆãƒ©ã‚¤ä¸­... ({attempt + 1}/{max_attempts})")
                        time.sleep(15)  # ãƒªãƒˆãƒ©ã‚¤å‰å¾…æ©Ÿæ™‚é–“å»¶é•·
                        continue
                    else:
                        raise Exception(f"VPNæ¥ç¶šå¤±æ•—: {account_id}")
                
                # æ¥ç¶šå®‰å®šåŒ–å¾…æ©Ÿ
                time.sleep(8)  # VPNæ¥ç¶šå®‰å®šåŒ–å¾…æ©Ÿ
                
                # 4. IPå¤‰åŒ–ç¢ºèª
                vpn_info = self.vpn_manager.get_connection_info()
                current_ip_after = vpn_info['current_ip']
                
                if current_ip_after != current_ip_before:
                    self.logger.info(f"âœ… VPNåˆ‡ã‚Šæ›¿ãˆæˆåŠŸ: {account_id} â†’ {current_ip_after}")
                    break
                else:
                    if attempt < max_attempts - 1:
                        self.logger.warning(f"IPå¤‰åŒ–ãªã—ã€å†è©¦è¡Œä¸­... ({current_ip_after})")
                        self.vpn_manager.disconnect()
                        time.sleep(10)
                    else:
                        self.logger.warning(f"âš ï¸ IPå¤‰åŒ–ãªã—ã€ç¶™ç¶šå®Ÿè¡Œ: {current_ip_after}")
                        # IPå¤‰åŒ–ãŒãªãã¦ã‚‚å‡¦ç†ç¶šè¡Œï¼ˆåŒä¸€ã‚µãƒ¼ãƒãƒ¼ã®å¯èƒ½æ€§ï¼‰
            
            # 5. Chromeèµ·å‹•(URLæŒ‡å®šãªã—)
            chrome_success = self.chrome_manager.start_chrome_profile(
                account_id, ""
            )
            if not chrome_success:
                raise Exception("Chromeèµ·å‹•å¤±æ•—")
            
            # 6. ãƒšãƒ¼ã‚¸æº–å‚™
            time.sleep(10)
            
            # ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦æœ€å¤§åŒ–
            pyautogui.hotkey('alt', 'space')
            time.sleep(1)
            pyautogui.press('x')
            time.sleep(2)
            
            # 7. ãƒ„ã‚¤ãƒ¼ãƒˆå–å¾— â†’ å³åº§ã«ä½¿ç”¨æ¸ˆã¿åŒ–
            tweet_data = self.get_random_unused_tweet(account_id)
            if not tweet_data:
                raise Exception("æŠ•ç¨¿å¯èƒ½ãƒ„ã‚¤ãƒ¼ãƒˆãªã—")
            
            self.mark_tweet_as_used(account_id, tweet_data['id'])
            self.logger.info(f"ãƒ„ã‚¤ãƒ¼ãƒˆé¸æŠãƒ»ä½¿ç”¨æ¸ˆã¿åŒ–: {tweet_data['text'][:30]}...")
            
            # 8. ThreadsæŠ•ç¨¿å®Ÿè¡Œ
            post_success = self._execute_threads_post(tweet_data['text'])
            
            if post_success:
                self.logger.info("æŠ•ç¨¿æˆåŠŸ")
            else:
                self.logger.warning("æŠ•ç¨¿å¤±æ•—ï¼ˆãƒ„ã‚¤ãƒ¼ãƒˆã¯æ—¢ã«ä½¿ç”¨æ¸ˆã¿ï¼‰")
            
            return True
            
        except Exception as e:
            self.logger.error(f"æŠ•ç¨¿å‡¦ç†ã‚¨ãƒ©ãƒ¼: {account_id} - {str(e)}")
            
            # ãƒ„ã‚¤ãƒ¼ãƒˆå–å¾—å‰ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ä»£æ›¿ãƒ„ã‚¤ãƒ¼ãƒˆæ¶ˆåŒ–
            if tweet_data is None:
                fallback_tweet = self.get_random_unused_tweet(account_id)
                if fallback_tweet:
                    self.mark_tweet_as_used(account_id, tweet_data['id']) 
                    self.logger.info("ä»£æ›¿ãƒ„ã‚¤ãƒ¼ãƒˆä½¿ç”¨æ¸ˆã¿åŒ–")
            
            return False
            
        finally:
            # å¿…é ˆã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—: Chromeçµ‚äº† â†’ VPNåˆ‡æ–­
            try:
                self.logger.info(f"ğŸ§¹ ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–‹å§‹: {account_id}")
                
                # Chromeçµ‚äº†
                self.chrome_manager.close_chrome_profile(account_id)
                self.logger.info(f"âœ… Chromeçµ‚äº†å®Œäº†: {account_id}")
                
                # VPNåˆ‡æ–­
                self.vpn_manager.disconnect()
                
            except Exception as cleanup_error:
                self.logger.warning(f"âš  ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼: {account_id} - {str(cleanup_error)}")

    def _execute_threads_post(self, content: str) -> bool:
        """ThreadsæŠ•ç¨¿å®Ÿè¡Œ"""
        try:
            # ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢èªè­˜ãƒ»ã‚¯ãƒªãƒƒã‚¯
            if not self._click_threads_textarea():
                return False
            
            # æŠ•ç¨¿å†…å®¹å…¥åŠ›
            import pyperclip
            pyperclip.copy(content)                # ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼
            time.sleep(2)                       # å®‰å®šæ€§ã®ãŸã‚å°‘ã—å¾…æ©Ÿ
            pyautogui.hotkey('ctrl', 'v')         # Ctrl+Vã§ãƒšãƒ¼ã‚¹ãƒˆ
            time.sleep(5)                         # å…¥åŠ›å®Œäº†å¾…æ©Ÿ
            
            # æŠ•ç¨¿ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯
            if not self._click_threads_post_button():
                return False
            
            time.sleep(5)  # æŠ•ç¨¿å®Œäº†å¾…æ©Ÿ
            return True
            
        except Exception as e:
            self.logger.error(f"ThreadsæŠ•ç¨¿ã‚¨ãƒ©ãƒ¼: {str(e)}")
            return False
    
    def _click_threads_textarea(self) -> bool:
        """Threadsãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã‚¯ãƒªãƒƒã‚¯"""
        try:
            textarea_image = self.image_dir / "threads_textarea.png"
            if not textarea_image.exists():
                self.logger.error("threads_textarea.png ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return False
            
            for attempt in range(3):
                try:
                    location = pyautogui.locateOnScreen(str(textarea_image), confidence=self.confidence)
                    if location:
                        center = pyautogui.center(location)
                        pyautogui.click(center.x, center.y)
                        time.sleep(1)
                        return True
                except pyautogui.ImageNotFoundException:
                    pass
                
                if attempt < 2:
                    time.sleep(2)
            
            return False
            
        except Exception as e:
            self.logger.error(f"Threadsãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢èªè­˜ã‚¨ãƒ©ãƒ¼: {str(e)}")
            return False
    
    def _click_threads_post_button(self) -> bool:
        """ThreadsæŠ•ç¨¿ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯"""
        try:
            post_image = self.image_dir / "threads_post_button.png"
            if not post_image.exists():
                self.logger.error("threads_post_button.png ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")
                return False
            
            for attempt in range(3):
                try:
                    location = pyautogui.locateOnScreen(str(post_image), confidence=0.95)
                    if location:
                        center = pyautogui.center(location)
                        pyautogui.click(center.x, center.y)
                        time.sleep(5)
                        return True
                except pyautogui.ImageNotFoundException:
                    pass
                
                if attempt < 2:
                    time.sleep(2)
            
            return False
            
        except Exception as e:
            self.logger.error(f"ThreadsæŠ•ç¨¿ãƒœã‚¿ãƒ³èªè­˜ã‚¨ãƒ©ãƒ¼: {str(e)}")
            return False